# Module 01 - Getting your Python On





## Welcome to the course
Welcome to the course!
In this course, you’ll learn how to use Python to perform system administration tasks and interact with a computer’s operating system. You’re about to embark on an exciting journey to learn one of the most in-demand job skills in IT today!

Course menu showing courses 1-6. Course 1 is complete. Course 2 is active and courses 3-6 are not yet complete.
This is the second course in the program.

Crash Course on Python
 

Using Python to Interact with the Operating System (this course)

Introduction to Git and GitHub

Troubleshooting and Debugging Techniques

Configuration Management and the Cloud

Automating Real-World Tasks with Python

Accelerate Your Job Search with AI

Course prerequisites
This course builds upon the contents taught in the introduction to Python course:

The basic Python syntax (if, for, while, defining functions, classes, and methods)

How to use the most common data structures (strings, lists, tuples, and dictionaries)

How to import and use additional Python modules

 This course also requires some familiarity with some basic operating system concepts:

Files, directories, and file systems

Processes

Log files

To get the most out of this course, we strongly recommend that you install software in your machine, or have your system administrator install it.

Obtain the Google IT Automation with Python Certificate
To receive your official Google IT Automation with Python Certificate, you must:

Pass all graded assignments in all 7 courses of the certificate program. Each graded assignment is part of a cumulative graded score for the course, and the passing grade for each course is 80%. 

AND one of the following:

Pay the
 course certificate fee
,

Be approved for
 Coursera Financial Aid
, or

Complete the certificate through an educational institution, employer, or agency that's sponsoring your participation. 

Healthy habits for course completion
Here is a list of best practices that will help you complete the courses in the program in a timely manner: 

Plan your time: Setting regular study times and following them each week can help you make learning a part of your routine. Use a calendar or timetable to create a schedule, and list what you plan to do each day in order to set achievable goals. Find a space that allows you to focus when you watch the videos, review the readings, and complete the activities.

Work at your own pace: Everyone learns differently, so this program has been designed to let you work at your own pace. Although your personalized deadlines start when you enroll, feel free to progress through the program at the speed that works best for you. There is no penalty for late assignments; to earn your certificate, all you have to do is complete all of the work. You can extend your deadlines at any time by going to Overview in the navigation panel and selecting Switch Sessions. If you have already missed previous deadlines, select Reset my deadlines instead.

Be curious: If you find an idea that gets you excited, act on it! Enrich your learning experience with Gemini's
 Guided Learning feature
. It acts as your personal learning assistant, helping you ask insightful questions, find more details online, and explore interesting topics. The steps you take to support your learning along the way will advance your knowledge, create more opportunities in this high-growth field, and help you qualify for jobs. 

Take notes: Notes will help you remember important information in the future, especially as you’re preparing to enter a new job field. In addition, taking notes is an effective way to make connections between topics and gain a better understanding of those topics.

Review exemplars: Exemplars are completed assignments that fully meet an activity's criteria. Many activities in this program have exemplars for you to compare to your own work. Although there are often many ways to complete an assignment, exemplars offer you guidance and inspiration about how to complete the activity. 

Build your Career Identity: Your career identity is the unique value you bring to the workforce.
 Watch this video
 to learn about the key components of career identity and write your own career identity statement. Discovering and defining your own career identity makes you better equipped to choose a career path that aligns with your strengths, values, and goals and is more effective in your chosen profession.

Connect with other learners: If you have a question, chances are, you’re not alone. You can visit Coursera’s private
 Google IT 201 Automation with Python Community
 to expand your network, discuss career journeys, and share experiences. You can also check out the
 quick start guide
.

Coursera learner support: Use the
 Learner Help Center
 to find information on specific technical issues. These include error messages, difficulty submitting assignments, or problems with video playback. If you can’t find an answer in the documentation, you can also report your problem to the Coursera support team by clicking on the Contact Us! link available at the bottom of help center articles.

Update your profile: Consider
 updating your profile
 on Coursera to include your photo, career goals, and more. When other learners find you in the Community, they can click on your name to access your profile and get to know you better.

Finding out more information
Throughout this course, we teach you how to do a range of things with Python, Bash, and other tools. While we’ll provide a lot of information through videos and supplemental readings, sometimes, you may need to look things up on your own, now and throughout your career. Things change fast in IT, so it’s critical to do your own research to stay up-to-date on what’s new. We recommend you use your favorite search engine to find more information about concepts we cover in this course — it’s great practice for the real world!

 On top of search results, here are some good programming resources available online:

Automate the Boring Stuff with Python
: This book (available online and in print) includes a lot of practical programming exercises for beginners. You can refer to this content to read more about some of the things that we'll be discussing, and get inspired with more ideas of things that can be automated.

Hitchhiker’s Guide to Python
: This site (available online and in print) also covers a lot of what we can do with Python. Again, you can use this resource to learn more about the subjects we cover (and the ones we had to omit for time constraints).

The 
official language reference
: Once you know what Python tool you'll be using to do a certain task, this technical reference of all Python language components can be a great resource.   

Note: As you progress this course you may see updated or repeated content due to Google’s regular review of the certificate program to provide the most up-to-date skills and tools in the industry. These changes include the addition of new practice material and supportive content. In addition, Google’s certificate updates sometimes include changes to graded items like quizzes and labs. If you have previously completed a graded item in this course, you may need to take a new assessment to complete this course. We hope the new content will support you on your learning journey!





## Pointers for Getting Your Environment Setup
Learning more about operating systems
We’ve talked briefly about what an operating system is and what we'll need to know about operating systems for this course. If you want to learn some additional operating system concepts, check out the videos on this subject in the 
Technical Support Fundamentals
 course. If you want to explore how to manage Windows and Linux, check out the 
Operating Systems and You: Becoming a Power User
 course.

If you want to discover more about the history of Unix, you can read all the details on the Unix 
Wikipedia page
.

Installing Python and additional modules
If you don't have Python installed yet, we recommend that you visit the 
official Python website
 and download the installer that corresponds to your operating system.

 There’s a bunch of guides out there for installing Python and they all follow a similar process to the one we described in the videos. This 
guide from Real Python
 includes instructions on how to install python on a range of different operating systems and distributions.

 Once you have Python installed on your operating system, it's a good idea to familiarize yourself with pip and the associated tools. You can find more info about these 
here
.

Using package management systems
Package management systems help you better manage the software installed on your machine. These management systems vary a lot from operating system to operating system. So, you need to pick the one that works for the OS you’re using. Check out these guides for help with this: 

Installing Python 3 on Windows 10 with Chocolatey

Installing Python 3 on MacOS with Homebrew

Package management basics on Linux

Other information
Python in the Microsoft Store for Windows 10





## Setting up Your Environment
After you’ve installed Python and checked that it works, the next step to set up your developer environment is to choose your main code editor. You’ve explored some code editors in Course 1.

Here are some additional common editors for Python, available for all platforms:

Eclipse

PyCharm

Sublime Text

Visual Studio Code

You can read more about these editors, and others, in these overview comparatives:

Python IDEs and Code Editors (Guide)
  This site compares tools that are built exclusively for Python code development and tools built for general development that you can use for Python and explains the pros and cons of each tool.

Best Python IDEs and Code Editors
 This site explains the importance of an integrated development environment (IDE) and compares a number of Python IDEs and code editors that can be used on platforms such as Windows, Mac, or Linux.

Top 6 Python IDEs for Data Science
 This site reviews common IDEs in terms of functionality to benefit projects for data scientists.

We encourage you to try out these editors and pick your favorite. Then, install it on your computer and experiment with writing and executing Python scripts locally. To review best practices for using and saving Python files, check out the following:

Review: Use the command-line

Use the command-line

Review: Use JupyterLab and Jupyter Notebooks

Use JupyterLab and Jupyter Notebooks

Review: Use Colab

Use Colab

Review: Use VS Code

Use VS Code

More on IDEs and code editors





## Virtual environments
A virtual environment in Python is a powerful tool that allows you to create isolated environments for your Python projects. Each environment acts as a sandbox, containing its own Python interpreter and library installations. This means you can have multiple projects with different dependencies, ensuring that they do not interfere with each other. In essence, virtual environments provide a clean slate where you can work on your projects without worrying about conflicting libraries or versions.


### Why use a virtual environment in Python?
Imagine you're working on two separate Python projects—one requires a specific version of a library, while the other relies on a newer version. Without virtual environments, managing these dependencies could become a nightmare. Here's where `virtual environments` shine: they allow you to keep your projects isolated, ensuring that changes in one environment do not impact another.

By using virtual environments, you can:
- Avoid conflicts between libraries and dependencies.
- Test different versions of libraries without affecting your system-wide Python installation.
- Maintain a clean and organized development environment.
- Collaborate with others while ensuring consistent library versions.


### Using a Python virtual environment
Creating and using a `virtual environment` is a straightforward process. To create a virtual environment, open your terminal and navigate to your project's directory. Then, run the following command:

```python
python -m venv myenv
```

This command creates a `virtual environment` named `myenv` in your project directory. To activate the virtual environment, use the appropriate command for your operating system:

On Windows:
`myenv\Scripts\activate`

On macOS and Linux:
`myenv/bin/activate`

Once activated, your terminal prompt will change, indicating that you are now working within the virtual environment. You can now install packages using `pip` just like you normally would.


### Best practices and recommendations
As you dive into the world of `virtual environments`, keep these best practices in mind:

1. **Create a virtual environment for each project:** Whenever you start a new project, create a new virtual environment. This ensures a clean and isolated workspace.

2. **Use requirements files:** To document and manage your project's dependencies, create a `requirements.txt` file. This file lists all the libraries and their versions. You can generate it using `pip freeze > requirements.txt` and later install them in a new environment using `pip install -r requirements.txt`.

3. **Activate and deactivate:** Always activate the appropriate virtual environment before working on a project and deactivate it when you're done. This prevents confusion and potential conflicts.

4. **Version control:** If you're collaborating with others, include the virtual environment setup instructions in your `version control system`. This ensures everyone is using the same environment.

5. **Upgrade pip and setuptools:** When you create a new virtual environment, it's a good practice to upgrade pip and setuptools to the latest version. This ensures you're using the most up-to-date tools.


### Key takeaways
Virtual environments are your key to maintaining a clean and efficient Python development workflow. By isolating your projects, you can work confidently, test various libraries, and ensure consistency across your codebase. With this newfound knowledge, you're well on your way to mastering the art of running Python locally and building robust applications. 

[https://docs.python.org/3/library/venv.html](https://docs.python.org/3/library/venv.html)






## Is it worth the time?
Think about a task or process you’ve completed at work time and time again. Have you ever thought that there has to be a more efficient way to execute this routine task or process? Chances are—you’re right. Companies research whether automating processes or tasks saves labor time (and thus money), offers a soft return on investment (ROI), or both. If it’s worth it, the automated process will save labor time for the company, soft ROI benefits, or both. 


### Soft ROI
Soft ROI through automation is difficult to measure because, typically, there are no hard numbers or data to support it. Soft ROI metrics include improving:
- Team collaboration
- Team morale
- Employee motivation
- Employee satisfaction

Think back to the task or process you complete weekly, or even daily. If this task was automated—as an employee—you would be less likely to be bored and, in return, be more motivated to complete other tasks that are not rote, creating high morale in the workplace.


### Is automation worthwhile?
To determine if automating a process would save labor time, use the following formula:

`Time_to_automate < (time_to_perform * amount_of_times_done)`

Let’s break down this formula and look at an example:

A banking company is looking to automate one of its internal processes that takes about 40 minutes each week to complete. The automation process will take 10 hours total to complete. How many weeks will it be before the banking company begins to save time on the process and automation would be worthwhile?

- time_to_automate = 10 hours
- time_to_perform = 40 minutes
- Amount_of_times_done = x 

**Pro tip:** Notice that you have two measurements of time. Before plugging values into the formula, convert 10 hours to minutes.

Multiply 10 by 60 to convert 10 hours into minutes. You get 600 minutes. 

When you plug your values into the formula from above, you get:

600 < 40x

**Pro tip:** x represents the number of weeks, so you can replace that with x in the formula.

Then, divide both sides by 40 to get:

	15 < weeks

It will take 15 weeks before the banking company starts saving time on the process. Remember, automating this process only needs to occur once. In addition, it helps employees by removing the need to think about the task and keeping up with the tracking of it.


### Key takeaways
Companies must decide whether it is worth the time, effort, and money to automate certain processes that are commonly used. To do this, calculate the ROI to determine if investing in workflow automation is beneficial to the company and its employees.   





## Glossary terms from Course 2, Module 1

### Terms and definitions from Course 2, Module 1
Compiled or compiled language: Supportable code that can be executed on different platforms

**Integrated Development Environment (IDE):** A code editor with extra capabilities to simplify script writing

**Interpreter or interpreted language:** An intermediary program used to execute the instructions specified in the code

**Kernel:** The main core of an operating system that talks directly to hardware and manages the system’s resource

**Linux:** An open source operating system where the software is free to share, modify, and distribute

**Mac OS:** Operating system developed by Apple

**Operating system (OS):** Software that manages everything that goes on in the computer, composed of two main parts: the kernel and the user space

**User space:** Everything outside of the kernel that users interact with directly

**Virtual environment:** A tool that allows you to create isolated environments for your Python projects

**Windows OS:** Operating system developed by Microsoft










# Module 02 - Managing Files with Python





## Reading files


### Introduction
These code blocks will provide you with the opportunity to see how the code is written, allow you to practice running it, and can be used as a reference to refer back to. 




### About this code 
```python
file = open("spider.txt")
```
This line opens the file `spider.txt` in read mode. The `open()` function returns a file object which is assigned to the variable file.


### About this code 
```python
file = open("spider.txt")
print(file.readline())
print(file.readline())
print(file.read())
file.close()
```
These lines print the first three lines of the file. The `readline()` method reads one line from the file and returns it as a string. The `read()` method reads the entire file and returns it as a string. The `close()` method closes the file.


### About this code 
```python
file = open("spider.txt")
print(file.readline())
print(file.readline())
print(file.read())
file.close()
with open("spider.txt") as file:
    print(file.readline())
```
Finally, the line that uses the `with` statement to open the file `spider.txt` is in read mode. The as keyword assigns the file object to the variable file. The code block inside the with statement will be executed, and then the file will be closed automatically.  





## Review: Iterating through files


### Introduction
These code blocks will provide you with the opportunity to see how the code is written, allow you to practice running it, and can be used as a reference to refer back to. 

#### About this code
```python
with open("spider.txt") as file:
    for line in file:
        print(line.upper())
About this code
```

**Code output:** 
```python
THE ITSY BITSY SPIDER CLIMBED UP THE WATERSPOUT.

DOWN CAME THE RAIN

AND WASHED THE SPIDER OUT.

OUT CAME THE SUN

AND DRIED UP ALL THE RAIN

AND THE ITSY BITSY SPIDER CLIMBED UP THE SPOUT AGAIN.
```

Here there are spaces between the lines in the output. This is because there is a new line character at the end of each line. 


#### About this code
```python
with open("spider.txt") as file:
    for line in file:
        print(line.strip().upper())
```

**Code output:** 
```python
THE ITSY BITSY SPIDER CLIMBED UP THE WATERSPOUT.
DOWN CAME THE RAIN
AND WASHED THE SPIDER OUT.
OUT CAME THE SUN
AND DRIED UP ALL THE RAIN
AND THE ITSY BITSY SPIDER CLIMBED UP THE SPOUT AGAIN.
```

Here strip is used to remove the newline character, and we get the output without empty lines.


#### About this code
```python
file = open("spider.txt")
lines = file.readlines()
file.close()
lines.sort()
print(lines)
```

**Code output:** 
```python
['Down came the rain\n', 'Out came the sun\n', 'The itsy bitsy spider climbed up the waterspout.\n', 'and dried up all the rain\n', 'and the itsy bitsy spider climbed up the spout again.\n', 'and washed the spider out.\n']
```

Here, the lines have been sorted alphabetically, so they're no longer in the order that they were in the file. We can see that Python displays a newline character using `\n` symbol when printing a list of strings. This is a way of explicitly showing that there's a new line character in those strings. This displays a character that's not printable, Python uses escape sequences with backslash, like `\n`. Another common escape sequence is `\t`, for tab.





## Review: Writing files


### Introduction
These code blocks will provide you with the opportunity to see how the code is written, allow you to practice running it, and can be used as a reference to refer back to. 

#### About this code
```python
with open("novel.txt", "w") as file:
    file.write("It was a dark and stormy night")
```

The with `open()` statement creates a file object and assigns it to the variable file. The `open()` function takes two arguments: the name of the file and the mode. In this case, the mode is `w`, which means "write". This tells the `open()` function to create a new file if it doesn't exist, or to overwrite the existing file if it does exist.

The `write()` method of the file object takes a string as its argument and writes the string to the file. In this case, the string is "It was a dark and stormy night".





## Study guide: Reading and writing files
Opening a file or file-like object to read or write is one of the fundamental steps of a Python programmer. For example, you may want to read a `.csv` file and convert it to `JSON` format. Or you may want to select data from a database and write it to an output file.

### Reading and writing files
To **read** or **write** a file, use `open()`. This function includes two arguments: the `file path` and the `mode`.

```python
with open("sample_data/declaration.txt", "rt") as textfile:
 for line in textfile:
   print(line)
```

In this example, the first argument is a string containing the filename `(sample_data/declaration.txt)`. The second argument identifies the mode or the way in which the file will be used `rt`. 
`r` means open for reading, and `t` tells Python to [expect a text file](https://docs.python.org/3/library/functions.html#open).

```python
f = open("sample_data/declaration.txt", “w”)
```

In this example, the code tells Python to open this file for writing (`w` mode). 


### Mode
The `mode` argument is optional, and it specifies the mode in which the file is opened. If omitted, it defaults to `r` and that means opening for reading in text mode. The common modes include:

- “r”  open for reading (default)
- “w”  open for writing, truncating the file first
- “x”  open for exclusive creation, failing if the file already exists
- “a”  open for writing, appending to the end of the file if it exists
- “+”  open for both reading and writing

Attempting to write to a file opened for read (“r”) will cause a runtime error.


### Encoding
Python distinguishes between binary mode (“b”) and text mode (“t”). By default, files are opened in the text mode, which means you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform-dependent. This means that locale.getencoding() is called to get the current locale encoding. If you need to open the text in a specific encoding, you must specify it.

```python
f = open('workfile', 'w', encoding="utf-8") 
```

In this example, the encoding=“utf-8” specifies that the file should be opened with UTF-8, the modern de facto standard. Binary mode data is read and written as bytes objects. You cannot specify encoding when opening a file in binary mode.

You have to have permission to write to the directory where you’re placing the file. It’s a best practice to always close a file .close() when you’re done working with it.


### Key takeaways
To open a file for reading or writing, use open(filename, mode). Two arguments that are needed include the file name and the mode. Python will encode the file as text (“t”) by default unless a specific encoding is specified.

### Resources for more information
More information about reading and writing files can be found in Built-in Functions:

https://docs.python.org/3/library/functions.html#open





## Review: How to write file paths in code

### Introduction
These code blocks will provide you with the opportunity to see how the code is written, allow you to practice running it, and can be used as a reference to refer back to. 

```python
#Windows file directory
C:\my-directory\target-file.txt
```

```python
#Windows file directory written in Python
C:/my-directory/target-file.txt.
```

```python
#Windows file directory
C:\\my-directory\\target-file.txt
```

```pyhon
#CWD command: 
os.getcwd()
```

```python
#CWD command for external files:
outputs['current_directory_before'] = os.getcwd()
```





## Working with files

These code blocks will provide you with the opportunity to see how the code is written, allow you to practice running it, and can be used as a reference to refer back to. 


### Remove
This code removes the file novel.txt
```python
 import os
 os.remove("novel.txt")
```

This code will throw a `file not found error`. You cannot remove a file that doesn’t exist.
```python
import os
os.remove("novel.txt")
os.remove("novel.txt")
```


### Rename
This code can be used to **rename** a file. 
```python
os.rename("first_draft.txt", "finished_masterpiece.txt")
```


### Exists
This code checks whether or not a file exists. If the file exists it will return `True`. If the file does not exist it will return `False`.
```python
 os.path.exists("finished_masterpiece.txt")
 os.path.exists("userlist.txt")
```


### Getsize 
This code will provide the file size
```python
os.path.getsize("spider.txt")

```


### Unix Timestamp
```python
os.path.getmtime("spider.txt")
#This code will provide a unix timestamp for the file
```


### Date and Time
This code will provide the **date and time** for the file in an `#easy-to-understand` format
```python
import datetime
timestamp = os.path.getmtime("spider.txt")
datetime.datetime.fromtimestamp(timestamp)
```


### Absolute path
This code takes the file name and turns it into an absolute path
```python
os.path.abspath("spider.txt")
```


### Working Directory
This code snippet returns the current working directory.
```python
print(os.getcwd())
```


### Create Directory
The os.mkdir("new_dir") function creates a new directory called new_dir
```python
os.mkdir("new_dir")
```


### Change Directory
This code snippet changes the current working directory to ```new_dir```. The second line prints the current working directory.

```python
os.chdir("new_dir")
os.getcwd()
```

### Delete Directory
This code snippet creates a new directory called newer_dir. The second line deletes the newer_dir directory.
```python
os.mkdir("newer_dir")
os.rmdir("newer_dir")
```


### List Directory
This code snippet returns a list of all the files and sub-directories in the website directory.
```python
import os
os.listdir("website")
```

### All together

Here is the code all together. This code defines a dir variable with the name of the directory that we want to check. This makes our code more readable and more usable. Then, it iterates through the file names returned by the os.listdir(). We know from our previous execution of this function that these are just the names of the files without directory. By using os.path.join(), we join the directory to each of those file names and create a string with a valid full name. Finally, we use that full name to call os.path.isdir() to check if it's a directory or a file. 

```python
 dir = "website"
 for name in os.listdir(dir):
     fullname = os.path.join(dir, name)
     if os.path.isdir(fullname):
          print("{} is a directory".format(fullname))
     else:
          print("{} is a file".format(fullname))
```





## Study guide: Files and directories
Managing files and directories includes creating, deleting, and moving files and directories. It also includes changing ownership and permissions of the files and directories. There are several ways to **manage files and directories in Python**. One of the easiest ways is to use low-level functions in the OS and SYS modules that closely mimic standard Linux commands such as `os.mkdir()`and  `os.rmdir()`. Alternatively, you can utilize the `Pathlib` module, which provides an object-oriented interface to working with the file systems. 

Let’s take a look at two examples. The first example uses `OS`; the second uses `Pathlib`. These two code examples **do the same thing**: They create a directory called test1 and move a file named README.md from the sample_data folder into test1.


### Using OS function
An example of using the `OS` function to create a directory and move a file:

```python
# Create a directory and move a file from one directory to another
# using low-level OS functions.

import os

# Check to see if a directory named "test1" exists under the current
# directory. If not, create it:
dest_dir = os.path.join(os.getcwd(), "test1")
if not os.path.exists(dest_dir):
 os.mkdir(dest_dir)


# Construct source and destination paths:
src_file = os.path.join(os.getcwd(), "sample_data", "README.md")
dest_file = os.path.join(os.getcwd(), "test1", "README.md")


# Move the file from its original location to the destination:
os.rename(src_file, dest_file)
```

### Using Pathlib
Here is an example of using `Pathlib` to create a directory and move a file:

```python
# Create a directory and move a file from one directory to another
# using Pathlib.

from pathlib import Path

# Check to see if the "test1" subdirectory exists. If not, create it:
dest_dir = Path("./test1/")
if not dest_dir.exists():
  dest_dir.mkdir()

# Construct source and destination paths:
src_file = Path("./sample_data/README.md")
dest_file = dest_dir / "README.md"

# Move the file from its original location to the destination:
src_file.rename(dest_file)
```


### The OS module 
Python’s `OS` module, or the miscellaneous operating system interface, is very useful for file operations, directories, and permissions. Let’s take a look at each.


### File operations
File names can be thought of as two names separated by a dot. For example, helloworld.txt is the file name and the extension defines the file type. OS provides functions to create, read, update, and delete files. Some of the basic functions include:
- Opening and closing files
- Reading from and writing to files
- Appending to files


### Directories
OS also provides functions to create, read, update, and delete directories, as well as change directories and list files. Knowing how to use these functions is key to working with files. For example, `os.listdir( path )` returns a list of all files and subdirectories in a directory.


### Permissions
Having the ability to update file permissions is an important aspect of making installations from a terminal window. The `os.chmod()` provides the ability to create, read, and update permissions for individuals or groups.


### Things to keep in mind  
One thing to be aware of is that `Python` treats text and binary files differently. Because Python is cross-platform, it tries to automatically handle different ASCII line endings. If you’re processing a binary file, make sure to open it in binary mode so Python doesn’t try to “fix” newlines in a binary file.

A best practice is to always `close()` a file when you’re done reading or writing to it. Even though Python usually closes them for you, it’s a good signal to other people reading your code that you’re done with that file. Make sure to catch any potential errors from filesystem calls, such as permission denied, file not found, and so on. Generally, you wrap them in try/except to handle those errors.


### Key takeaways
There are several ways to manage files and directories in `Python`. One way is to use low-level functions in the OS and SYS modules that closely mimic standard Linux commands. Another way is to utilize the Pathlib module, which provides an object-oriented interface to working with the file systems. 


### Resources for more information
More information about files and directories can be found in several resources provided below: 
- https://docs.python.org/3/library/os.html
- https://docs.python.org/3/library/os.path.html
- https://en.wikipedia.org/wiki/Unix_time





# Module 03 - Regular Expressions




# Module 04 - Managing Data and Processes





# Module 05 - Testing in Python





# Module 06 - Bash Scripting




# Module 07 - Final Project










# Public

[img010101]: /back-end-development/public/img010101_path_selected.png
[img010102]: /back-end-development/public/img010102_initial_screen.png
[img010103]: /back-end-development/public/img010103_mac_install_app.png
[img010104]: /back-end-development/public/img010104_extensions_icon.png
[img010105]: /back-end-development/public/img010105_python_extension.png
[img010106]: /back-end-development/public/img010106_Screenshot-2022-06-23-at-16.58.30.png
[img010107]: /back-end-development/public/img010107_Screenshot-2022-06-23-at-17.04.00.png
[img010108]: /back-end-development/public/img010108_Screenshot-2022-06-23-at-17.12.24.png

[img020101]: /back-end-development/public/img020101_For-Loop-Program.png
[img020102]: /back-end-development/public/img020102_BED_C2M1L3_item07-img02.png
[img020201]: /back-end-development/public/img020201_item04-img01.png